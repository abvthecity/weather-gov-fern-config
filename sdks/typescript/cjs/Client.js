"use strict";
/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbvthecityWeatherGovClient = void 0;
const core = __importStar(require("./core"));
const url_join_1 = __importDefault(require("url-join"));
const errors = __importStar(require("./errors/index"));
class AbvthecityWeatherGovClient {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Returns all currently active alerts
     *
     * @param {AbvthecityWeatherGov.AlertsActiveRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActive()
     */
    alertsActive() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { area, certainty, code, event, limit, message_type: messageType, point, region, region_type: regionType, severity, status, urgency, zone, } = request;
            const _queryParams = {};
            if (area != null) {
                if (Array.isArray(area)) {
                    _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
                }
            }
            if (certainty != null) {
                if (Array.isArray(certainty)) {
                    _queryParams["certainty"] = certainty.map((item) => item);
                }
                else {
                    _queryParams["certainty"] = certainty;
                }
            }
            if (code != null) {
                if (Array.isArray(code)) {
                    _queryParams["code"] = code.map((item) => item);
                }
                else {
                    _queryParams["code"] = code;
                }
            }
            if (event != null) {
                if (Array.isArray(event)) {
                    _queryParams["event"] = event.map((item) => item);
                }
                else {
                    _queryParams["event"] = event;
                }
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (messageType != null) {
                if (Array.isArray(messageType)) {
                    _queryParams["message_type"] = messageType.map((item) => item);
                }
                else {
                    _queryParams["message_type"] = messageType;
                }
            }
            if (point != null) {
                _queryParams["point"] = point;
            }
            if (region != null) {
                if (Array.isArray(region)) {
                    _queryParams["region"] = region.map((item) => item);
                }
                else {
                    _queryParams["region"] = region;
                }
            }
            if (regionType != null) {
                _queryParams["region_type"] = regionType;
            }
            if (severity != null) {
                if (Array.isArray(severity)) {
                    _queryParams["severity"] = severity.map((item) => item);
                }
                else {
                    _queryParams["severity"] = severity;
                }
            }
            if (status != null) {
                if (Array.isArray(status)) {
                    _queryParams["status"] = status.map((item) => item);
                }
                else {
                    _queryParams["status"] = status;
                }
            }
            if (urgency != null) {
                if (Array.isArray(urgency)) {
                    _queryParams["urgency"] = urgency.map((item) => item);
                }
                else {
                    _queryParams["urgency"] = urgency;
                }
            }
            if (zone != null) {
                if (Array.isArray(zone)) {
                    _queryParams["zone"] = zone.map((item) => item);
                }
                else {
                    _queryParams["zone"] = zone;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "alerts/active"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns active alerts for the given area (state or marine area)
     *
     * @param {AbvthecityWeatherGov.AreaCode} area - State/area ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveArea("AL")
     */
    alertsActiveArea(area, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `alerts/active/area/${encodeURIComponent(area)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active/area/{area}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns info on the number of active alerts
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveCount()
     */
    alertsActiveCount(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "alerts/active/count"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active/count.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns active alerts for the given marine region
     *
     * @param {AbvthecityWeatherGov.MarineRegionCode} region - Marine region ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveRegion("AL")
     */
    alertsActiveRegion(region, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `alerts/active/region/${encodeURIComponent(region)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active/region/{region}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns active alerts for the given NWS public zone or county
     *
     * @param {AbvthecityWeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveZone("zoneId")
     */
    alertsActiveZone(zoneId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `alerts/active/zone/${encodeURIComponent(zoneId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active/zone/{zoneId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns all alerts
     *
     * @param {AbvthecityWeatherGov.AlertsQueryRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsQuery()
     */
    alertsQuery() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { active, area, certainty, code, cursor, end, event, limit, message_type: messageType, point, region, region_type: regionType, severity, start, status, urgency, zone, } = request;
            const _queryParams = {};
            if (active != null) {
                _queryParams["active"] = active.toString();
            }
            if (area != null) {
                if (Array.isArray(area)) {
                    _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
                }
            }
            if (certainty != null) {
                if (Array.isArray(certainty)) {
                    _queryParams["certainty"] = certainty.map((item) => item);
                }
                else {
                    _queryParams["certainty"] = certainty;
                }
            }
            if (code != null) {
                if (Array.isArray(code)) {
                    _queryParams["code"] = code.map((item) => item);
                }
                else {
                    _queryParams["code"] = code;
                }
            }
            if (cursor != null) {
                _queryParams["cursor"] = cursor;
            }
            if (end != null) {
                _queryParams["end"] = end;
            }
            if (event != null) {
                if (Array.isArray(event)) {
                    _queryParams["event"] = event.map((item) => item);
                }
                else {
                    _queryParams["event"] = event;
                }
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (messageType != null) {
                if (Array.isArray(messageType)) {
                    _queryParams["message_type"] = messageType.map((item) => item);
                }
                else {
                    _queryParams["message_type"] = messageType;
                }
            }
            if (point != null) {
                _queryParams["point"] = point;
            }
            if (region != null) {
                if (Array.isArray(region)) {
                    _queryParams["region"] = region.map((item) => item);
                }
                else {
                    _queryParams["region"] = region;
                }
            }
            if (regionType != null) {
                _queryParams["region_type"] = regionType;
            }
            if (severity != null) {
                if (Array.isArray(severity)) {
                    _queryParams["severity"] = severity.map((item) => item);
                }
                else {
                    _queryParams["severity"] = severity;
                }
            }
            if (start != null) {
                _queryParams["start"] = start;
            }
            if (status != null) {
                if (Array.isArray(status)) {
                    _queryParams["status"] = status.map((item) => item);
                }
                else {
                    _queryParams["status"] = status;
                }
            }
            if (urgency != null) {
                if (Array.isArray(urgency)) {
                    _queryParams["urgency"] = urgency.map((item) => item);
                }
                else {
                    _queryParams["urgency"] = urgency;
                }
            }
            if (zone != null) {
                if (Array.isArray(zone)) {
                    _queryParams["zone"] = zone.map((item) => item);
                }
                else {
                    _queryParams["zone"] = zone;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "alerts"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a specific alert
     *
     * @param {AbvthecityWeatherGov.AlertId} id - Alert identifier
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsSingle("id")
     */
    alertsSingle(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `alerts/${encodeURIComponent(id)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/{id}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of alert types
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsTypes()
     */
    alertsTypes(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "alerts/types"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/types.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of Center Weather Advisories from a CWSU
     *
     * @param {AbvthecityWeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {AbvthecityWeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {number} sequence - Sequence number
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwa("ZAB", "date", 1)
     */
    cwa(cwsuId, date, sequence, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/cwsus/${encodeURIComponent(cwsuId)}/cwas/${encodeURIComponent(date)}/${encodeURIComponent(sequence)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of Center Weather Advisories from a CWSU
     *
     * @param {AbvthecityWeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwas("ZAB")
     */
    cwas(cwsuId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/cwsus/${encodeURIComponent(cwsuId)}/cwas`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}/cwas.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a Center Weather Service Unit
     *
     * @param {AbvthecityWeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwsu("ZAB")
     */
    cwsu(cwsuId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/cwsus/${encodeURIComponent(cwsuId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns glossary terms
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.glossary()
     */
    glossary(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "glossary"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /glossary.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     *
     * @param {AbvthecityWeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpoint("AKQ", 1, 1)
     */
    gridpoint(wfo, x, y, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a textual forecast for a 2.5km grid area
     *
     * @param {AbvthecityWeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {AbvthecityWeatherGov.GridpointForecastRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointForecast("AKQ", 1, 1)
     */
    gridpointForecast(wfo_1, x_1, y_1) {
        return __awaiter(this, arguments, void 0, function* (wfo, x, y, request = {}, requestOptions) {
            const { units, "Feature-Flags": featureFlags } = request;
            const _queryParams = {};
            if (units != null) {
                _queryParams["units"] = units;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/forecast`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version, "Feature-Flags": featureFlags != null ? JSON.stringify(featureFlags) : undefined }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/forecast.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     *
     * @param {AbvthecityWeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {AbvthecityWeatherGov.GridpointForecastHourlyRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointForecastHourly("AKQ", 1, 1)
     */
    gridpointForecastHourly(wfo_1, x_1, y_1) {
        return __awaiter(this, arguments, void 0, function* (wfo, x, y, request = {}, requestOptions) {
            const { units, "Feature-Flags": featureFlags } = request;
            const _queryParams = {};
            if (units != null) {
                _queryParams["units"] = units;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/forecast/hourly`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version, "Feature-Flags": featureFlags != null ? JSON.stringify(featureFlags) : undefined }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/forecast/hourly.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     *
     * @param {AbvthecityWeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {AbvthecityWeatherGov.GridpointStationsRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointStations("AKQ", 1, 1)
     */
    gridpointStations(wfo_1, x_1, y_1) {
        return __awaiter(this, arguments, void 0, function* (wfo, x, y, request = {}, requestOptions) {
            const { cursor, limit } = request;
            const _queryParams = {};
            if (cursor != null) {
                _queryParams["cursor"] = cursor;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/stations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/stations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     */
    icons(first_1, set_1, timeOfDay_1) {
        return __awaiter(this, arguments, void 0, function* (first, set_, timeOfDay, request = {}, requestOptions) {
            const { fontsize, size } = request;
            const _queryParams = {};
            if (fontsize != null) {
                _queryParams["fontsize"] = fontsize.toString();
            }
            if (size != null) {
                _queryParams["size"] = size;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `icons/${encodeURIComponent(set_)}/${encodeURIComponent(timeOfDay)}/${encodeURIComponent(first)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                responseType: "streaming",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /icons/{set}/{timeOfDay}/{first}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.iconsSummary()
     */
    iconsSummary(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "icons"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /icons.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     */
    iconsDualCondition(first_1, second_1, set_1, timeOfDay_1) {
        return __awaiter(this, arguments, void 0, function* (first, second, set_, timeOfDay, request = {}, requestOptions) {
            const { fontsize, size } = request;
            const _queryParams = {};
            if (fontsize != null) {
                _queryParams["fontsize"] = fontsize.toString();
            }
            if (size != null) {
                _queryParams["size"] = size;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `icons/${encodeURIComponent(set_)}/${encodeURIComponent(timeOfDay)}/${encodeURIComponent(first)}/${encodeURIComponent(second)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                responseType: "streaming",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /icons/{set}/{timeOfDay}/{first}/{second}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of valid text product types for a given issuance location
     *
     * @param {string} locationId - .
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.locationProducts("locationId")
     */
    locationProducts(locationId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `products/locations/${encodeURIComponent(locationId)}/types`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/locations/{locationId}/types.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given observation station
     *
     * @param {string} stationId - Observation station ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.obsStation("stationId")
     */
    obsStation(stationId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observation stations.
     *
     * @param {AbvthecityWeatherGov.ObsStationsRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.obsStations()
     */
    obsStations() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { cursor, id, limit, state } = request;
            const _queryParams = {};
            if (cursor != null) {
                _queryParams["cursor"] = cursor;
            }
            if (id != null) {
                if (Array.isArray(id)) {
                    _queryParams["id"] = id.map((item) => item);
                }
                else {
                    _queryParams["id"] = id;
                }
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (state != null) {
                if (Array.isArray(state)) {
                    _queryParams["state"] = state.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["state"] = typeof state === "string" ? state : JSON.stringify(state);
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "stations"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a NWS forecast office
     *
     * @param {AbvthecityWeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.office("AKQ")
     */
    office(officeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `offices/${encodeURIComponent(officeId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /offices/{officeId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a specific news headline for a given NWS office
     *
     * @param {string} headlineId - Headline record ID
     * @param {AbvthecityWeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.officeHeadline("headlineId", "AKQ")
     */
    officeHeadline(headlineId, officeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `offices/${encodeURIComponent(officeId)}/headlines/${encodeURIComponent(headlineId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /offices/{officeId}/headlines/{headlineId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of news headlines for a given NWS office
     *
     * @param {AbvthecityWeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.officeHeadlines("AKQ")
     */
    officeHeadlines(officeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `offices/${encodeURIComponent(officeId)}/headlines`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /offices/{officeId}/headlines.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given latitude/longitude point
     *
     * @param {AbvthecityWeatherGov.PointString} point - Point (latitude, longitude)
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.point("point")
     */
    point(point, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `points/${encodeURIComponent(point)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /points/{point}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observation stations for a given point
     *
     * @param {AbvthecityWeatherGov.PointString} point - Point (latitude, longitude)
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.pointStations("point")
     */
    pointStations(point, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `points/${encodeURIComponent(point)}/stations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /points/{point}/stations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a specific text product
     *
     * @param {string} productId - .
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.product("productId")
     */
    product(productId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `products/${encodeURIComponent(productId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/{productId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of valid text product issuance locations
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productLocations()
     */
    productLocations(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "products/locations"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/locations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of valid text product types and codes
     *
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productTypes()
     */
    productTypes(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "products/types"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/types.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of text products
     *
     * @param {AbvthecityWeatherGov.ProductsQueryRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsQuery()
     */
    productsQuery() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { end, limit, location, office, start, type: type_, wmoid } = request;
            const _queryParams = {};
            if (end != null) {
                _queryParams["end"] = end;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (location != null) {
                if (Array.isArray(location)) {
                    _queryParams["location"] = location.map((item) => item);
                }
                else {
                    _queryParams["location"] = location;
                }
            }
            if (office != null) {
                if (Array.isArray(office)) {
                    _queryParams["office"] = office.map((item) => item);
                }
                else {
                    _queryParams["office"] = office;
                }
            }
            if (start != null) {
                _queryParams["start"] = start;
            }
            if (type_ != null) {
                if (Array.isArray(type_)) {
                    _queryParams["type"] = type_.map((item) => item);
                }
                else {
                    _queryParams["type"] = type_;
                }
            }
            if (wmoid != null) {
                if (Array.isArray(wmoid)) {
                    _queryParams["wmoid"] = wmoid.map((item) => item);
                }
                else {
                    _queryParams["wmoid"] = wmoid;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "products"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of text products of a given type
     *
     * @param {string} typeId - .
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsType("typeId")
     */
    productsType(typeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `products/types/${encodeURIComponent(typeId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/types/{typeId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of text products of a given type for a given issuance location
     *
     * @param {string} locationId - .
     * @param {string} typeId - .
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsTypeLocation("locationId", "typeId")
     */
    productsTypeLocation(locationId, typeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `products/types/${encodeURIComponent(typeId)}/locations/${encodeURIComponent(locationId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/types/{typeId}/locations/{locationId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of valid text product issuance locations for a given product type
     *
     * @param {string} typeId - .
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsTypeLocations("typeId")
     */
    productsTypeLocations(typeId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `products/types/${encodeURIComponent(typeId)}/locations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /products/types/{typeId}/locations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given radar wind profiler
     *
     * @param {string} stationId - Profiler station ID
     * @param {AbvthecityWeatherGov.RadarProfilerRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarProfiler("stationId", {
     *         interval: "P2DT12H",
     *         time: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
     *     })
     */
    radarProfiler(stationId_1) {
        return __awaiter(this, arguments, void 0, function* (stationId, request = {}, requestOptions) {
            const { interval, time } = request;
            const _queryParams = {};
            if (interval != null) {
                _queryParams["interval"] = interval;
            }
            if (time != null) {
                _queryParams["time"] = time;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `radar/profilers/${encodeURIComponent(stationId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/profilers/{stationId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given radar queue
     *
     * @param {string} host - LDM host
     * @param {AbvthecityWeatherGov.RadarQueueRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarQueue("host", {
     *         arrived: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z",
     *         created: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z",
     *         published: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
     *     })
     */
    radarQueue(host_1) {
        return __awaiter(this, arguments, void 0, function* (host, request = {}, requestOptions) {
            const { arrived, created, feed, limit, published, resolution, station, type: type_ } = request;
            const _queryParams = {};
            if (arrived != null) {
                _queryParams["arrived"] = arrived;
            }
            if (created != null) {
                _queryParams["created"] = created;
            }
            if (feed != null) {
                _queryParams["feed"] = feed;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (published != null) {
                _queryParams["published"] = published;
            }
            if (resolution != null) {
                _queryParams["resolution"] = resolution.toString();
            }
            if (station != null) {
                _queryParams["station"] = station;
            }
            if (type_ != null) {
                _queryParams["type"] = type_;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `radar/queues/${encodeURIComponent(host)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/queues/{host}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given radar server
     *
     * @param {string} id - Server ID
     * @param {AbvthecityWeatherGov.RadarServerRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarServer("id")
     */
    radarServer(id_1) {
        return __awaiter(this, arguments, void 0, function* (id, request = {}, requestOptions) {
            const { reportingHost } = request;
            const _queryParams = {};
            if (reportingHost != null) {
                _queryParams["reportingHost"] = reportingHost;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `radar/servers/${encodeURIComponent(id)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/servers/{id}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of radar servers
     *
     * @param {AbvthecityWeatherGov.RadarServersRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarServers()
     */
    radarServers() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { reportingHost } = request;
            const _queryParams = {};
            if (reportingHost != null) {
                _queryParams["reportingHost"] = reportingHost;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "radar/servers"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/servers.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given radar station
     *
     * @param {string} stationId - Radar station ID
     * @param {AbvthecityWeatherGov.RadarStationRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStation("stationId")
     */
    radarStation(stationId_1) {
        return __awaiter(this, arguments, void 0, function* (stationId, request = {}, requestOptions) {
            const { host, reportingHost } = request;
            const _queryParams = {};
            if (host != null) {
                _queryParams["host"] = host;
            }
            if (reportingHost != null) {
                _queryParams["reportingHost"] = reportingHost;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `radar/stations/${encodeURIComponent(stationId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/stations/{stationId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given radar station alarms
     *
     * @param {string} stationId - Radar station ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStationAlarms("stationId")
     */
    radarStationAlarms(stationId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `radar/stations/${encodeURIComponent(stationId)}/alarms`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/stations/{stationId}/alarms.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of radar stations
     *
     * @param {AbvthecityWeatherGov.RadarStationsRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStations()
     */
    radarStations() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { host, reportingHost, stationType } = request;
            const _queryParams = {};
            if (host != null) {
                _queryParams["host"] = host;
            }
            if (reportingHost != null) {
                _queryParams["reportingHost"] = reportingHost;
            }
            if (stationType != null) {
                if (Array.isArray(stationType)) {
                    _queryParams["stationType"] = stationType.map((item) => item);
                }
                else {
                    _queryParams["stationType"] = stationType;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "radar/stations"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /radar/stations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     */
    satelliteThumbnails(area, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `thumbnails/satellite/${encodeURIComponent(area)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                responseType: "streaming",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /thumbnails/satellite/{area}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a specific SIGMET/AIRMET
     *
     * @param {AbvthecityWeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {AbvthecityWeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {AbvthecityWeatherGov.Time} time - Time (HHMM format). This time is always specified in UTC (Zulu) time.
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmet("atsu", "date", "time")
     */
    sigmet(atsu, date, time, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/sigmets/${encodeURIComponent(atsu)}/${encodeURIComponent(date)}/${encodeURIComponent(time)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets/{atsu}/{date}/{time}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of SIGMET/AIRMETs
     *
     * @param {AbvthecityWeatherGov.SigmetQueryRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetQuery()
     */
    sigmetQuery() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { atsu, date, end, sequence, start } = request;
            const _queryParams = {};
            if (atsu != null) {
                _queryParams["atsu"] = atsu;
            }
            if (date != null) {
                _queryParams["date"] = date;
            }
            if (end != null) {
                _queryParams["end"] = end;
            }
            if (sequence != null) {
                _queryParams["sequence"] = sequence;
            }
            if (start != null) {
                _queryParams["start"] = start;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "aviation/sigmets"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU
     *
     * @param {AbvthecityWeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetsByAtsu("atsu")
     */
    sigmetsByAtsu(atsu, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/sigmets/${encodeURIComponent(atsu)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets/{atsu}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
     *
     * @param {AbvthecityWeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {AbvthecityWeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetsByAtsuByDate("atsu", "date")
     */
    sigmetsByAtsuByDate(atsu, date, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `aviation/sigmets/${encodeURIComponent(atsu)}/${encodeURIComponent(date)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets/{atsu}/{date}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns the latest observation for a station
     *
     * @param {string} stationId - Observation station ID
     * @param {AbvthecityWeatherGov.StationObservationLatestRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationLatest("stationId")
     */
    stationObservationLatest(stationId_1) {
        return __awaiter(this, arguments, void 0, function* (stationId, request = {}, requestOptions) {
            const { require_qc: requireQc } = request;
            const _queryParams = {};
            if (requireQc != null) {
                _queryParams["require_qc"] = requireQc.toString();
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}/observations/latest`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}/observations/latest.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observations for a given station
     *
     * @param {string} stationId - Observation station ID
     * @param {AbvthecityWeatherGov.StationObservationListRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationList("stationId")
     */
    stationObservationList(stationId_1) {
        return __awaiter(this, arguments, void 0, function* (stationId, request = {}, requestOptions) {
            const { end, limit, start } = request;
            const _queryParams = {};
            if (end != null) {
                _queryParams["end"] = end;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (start != null) {
                _queryParams["start"] = start;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}/observations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}/observations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a single observation.
     *
     * @param {string} stationId - Observation station ID
     * @param {string} time - Timestamp of requested observation
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationTime("stationId", "2024-01-15T09:30:00Z")
     */
    stationObservationTime(stationId, time, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}/observations/${encodeURIComponent(time)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}/observations/{time}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a single Terminal Aerodrome Forecast.
     *
     * @param {AbvthecityWeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {string} stationId - Observation station ID
     * @param {AbvthecityWeatherGov.Time} time - Time (HHMM format). This time is always specified in UTC (Zulu) time.
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.taf("date", "stationId", "time")
     */
    taf(date, stationId, time, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}/tafs/${encodeURIComponent(date)}/${encodeURIComponent(time)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}/tafs/{date}/{time}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns Terminal Aerodrome Forecasts for the specified airport station.
     *
     * @param {string} stationId - Observation station ID
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.tafs("stationId")
     */
    tafs(stationId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `stations/${encodeURIComponent(stationId)}/tafs`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}/tafs.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns metadata about a given zone
     *
     * @param {AbvthecityWeatherGov.NwsZoneType} type_ - Zone type
     * @param {AbvthecityWeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {AbvthecityWeatherGov.ZoneRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zone("land", "zoneId")
     */
    zone(type_1, zoneId_1) {
        return __awaiter(this, arguments, void 0, function* (type_, zoneId, request = {}, requestOptions) {
            const { effective } = request;
            const _queryParams = {};
            if (effective != null) {
                _queryParams["effective"] = effective;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `zones/${encodeURIComponent(type_)}/${encodeURIComponent(zoneId)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones/{type}/{zoneId}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns the current zone forecast for a given zone
     *
     * @param {string} type_ - Zone type
     * @param {AbvthecityWeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneForecast("type", "zoneId")
     */
    zoneForecast(type_, zoneId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `zones/${encodeURIComponent(type_)}/${encodeURIComponent(zoneId)}/forecast`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones/{type}/{zoneId}/forecast.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of zones
     *
     * @param {AbvthecityWeatherGov.ZoneListRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneList()
     */
    zoneList() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            const { area, effective, id, include_geometry: includeGeometry, limit, point, region, type: type_ } = request;
            const _queryParams = {};
            if (area != null) {
                if (Array.isArray(area)) {
                    _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
                }
            }
            if (effective != null) {
                _queryParams["effective"] = effective;
            }
            if (id != null) {
                if (Array.isArray(id)) {
                    _queryParams["id"] = id.map((item) => item);
                }
                else {
                    _queryParams["id"] = id;
                }
            }
            if (includeGeometry != null) {
                _queryParams["include_geometry"] = includeGeometry.toString();
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (point != null) {
                _queryParams["point"] = point;
            }
            if (region != null) {
                if (Array.isArray(region)) {
                    _queryParams["region"] = region.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["region"] = typeof region === "string" ? region : JSON.stringify(region);
                }
            }
            if (type_ != null) {
                if (Array.isArray(type_)) {
                    _queryParams["type"] = type_.map((item) => item);
                }
                else {
                    _queryParams["type"] = type_;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), "zones"),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of zones of a given type
     *
     * @param {AbvthecityWeatherGov.NwsZoneType} type_ - Zone type
     * @param {AbvthecityWeatherGov.ZoneListTypeRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneListType("land")
     */
    zoneListType(type_1) {
        return __awaiter(this, arguments, void 0, function* (type_, request = {}, requestOptions) {
            const { area, effective, id, include_geometry: includeGeometry, limit, point, region, type: type__ } = request;
            const _queryParams = {};
            if (area != null) {
                if (Array.isArray(area)) {
                    _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
                }
            }
            if (effective != null) {
                _queryParams["effective"] = effective;
            }
            if (id != null) {
                if (Array.isArray(id)) {
                    _queryParams["id"] = id.map((item) => item);
                }
                else {
                    _queryParams["id"] = id;
                }
            }
            if (includeGeometry != null) {
                _queryParams["include_geometry"] = includeGeometry.toString();
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (point != null) {
                _queryParams["point"] = point;
            }
            if (region != null) {
                if (Array.isArray(region)) {
                    _queryParams["region"] = region.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
                }
                else {
                    _queryParams["region"] = typeof region === "string" ? region : JSON.stringify(region);
                }
            }
            if (type__ != null) {
                if (Array.isArray(type__)) {
                    _queryParams["type"] = type__.map((item) => item);
                }
                else {
                    _queryParams["type"] = type__;
                }
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `zones/${encodeURIComponent(type_)}`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones/{type}.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observations for a given zone
     *
     * @param {AbvthecityWeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {AbvthecityWeatherGov.ZoneObsRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneObs("zoneId")
     */
    zoneObs(zoneId_1) {
        return __awaiter(this, arguments, void 0, function* (zoneId, request = {}, requestOptions) {
            const { end, limit, start } = request;
            const _queryParams = {};
            if (end != null) {
                _queryParams["end"] = end;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            if (start != null) {
                _queryParams["start"] = start;
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `zones/forecast/${encodeURIComponent(zoneId)}/observations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones/forecast/{zoneId}/observations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    /**
     * Returns a list of observation stations for a given zone
     *
     * @param {AbvthecityWeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {AbvthecityWeatherGov.ZoneStationsRequest} request
     * @param {AbvthecityWeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneStations("zoneId")
     */
    zoneStations(zoneId_1) {
        return __awaiter(this, arguments, void 0, function* (zoneId, request = {}, requestOptions) {
            const { cursor, limit } = request;
            const _queryParams = {};
            if (cursor != null) {
                _queryParams["cursor"] = cursor;
            }
            if (limit != null) {
                _queryParams["limit"] = limit.toString();
            }
            const _response = yield core.fetcher({
                url: (0, url_join_1.default)(yield core.Supplier.get(this._options.environment), `zones/forecast/${encodeURIComponent(zoneId)}/stations`),
                method: "GET",
                headers: Object.assign(Object.assign({ "X-Fern-Language": "JavaScript", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, (yield this._getCustomAuthorizationHeaders())), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
                contentType: "application/json",
                queryParameters: _queryParams,
                requestType: "json",
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return _response.body;
            }
            if (_response.error.reason === "status-code") {
                throw new errors.AbvthecityWeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.body,
                });
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new errors.AbvthecityWeatherGovError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                    });
                case "timeout":
                    throw new errors.AbvthecityWeatherGovTimeoutError("Timeout exceeded when calling GET /zones/forecast/{zoneId}/stations.");
                case "unknown":
                    throw new errors.AbvthecityWeatherGovError({
                        message: _response.error.errorMessage,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter(this, void 0, void 0, function* () {
            const userAgentValue = yield core.Supplier.get(this._options.userAgent);
            return { "User-Agent": userAgentValue };
        });
    }
}
exports.AbvthecityWeatherGovClient = AbvthecityWeatherGovClient;
