/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "./core";
import * as WeatherGov from "./api/index";
import urlJoin from "url-join";
import * as errors from "./errors/index";
import * as stream from "stream";

export declare namespace WeatherGovClient {
    export interface Options {
        environment: core.Supplier<string>;
        userAgent: core.Supplier<string>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class WeatherGovClient {
    constructor(protected readonly _options: WeatherGovClient.Options) {}

    /**
     * Returns all currently active alerts
     *
     * @param {WeatherGov.AlertsActiveRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActive()
     */
    public async alertsActive(
        request: WeatherGov.AlertsActiveRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertCollectionGeoJson> {
        const {
            area,
            certainty,
            code,
            event,
            limit,
            message_type: messageType,
            point,
            region,
            region_type: regionType,
            severity,
            status,
            urgency,
            zone,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (area != null) {
            if (Array.isArray(area)) {
                _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
            }
        }

        if (certainty != null) {
            if (Array.isArray(certainty)) {
                _queryParams["certainty"] = certainty.map((item) => item);
            } else {
                _queryParams["certainty"] = certainty;
            }
        }

        if (code != null) {
            if (Array.isArray(code)) {
                _queryParams["code"] = code.map((item) => item);
            } else {
                _queryParams["code"] = code;
            }
        }

        if (event != null) {
            if (Array.isArray(event)) {
                _queryParams["event"] = event.map((item) => item);
            } else {
                _queryParams["event"] = event;
            }
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (messageType != null) {
            if (Array.isArray(messageType)) {
                _queryParams["message_type"] = messageType.map((item) => item);
            } else {
                _queryParams["message_type"] = messageType;
            }
        }

        if (point != null) {
            _queryParams["point"] = point;
        }

        if (region != null) {
            if (Array.isArray(region)) {
                _queryParams["region"] = region.map((item) => item);
            } else {
                _queryParams["region"] = region;
            }
        }

        if (regionType != null) {
            _queryParams["region_type"] = regionType;
        }

        if (severity != null) {
            if (Array.isArray(severity)) {
                _queryParams["severity"] = severity.map((item) => item);
            } else {
                _queryParams["severity"] = severity;
            }
        }

        if (status != null) {
            if (Array.isArray(status)) {
                _queryParams["status"] = status.map((item) => item);
            } else {
                _queryParams["status"] = status;
            }
        }

        if (urgency != null) {
            if (Array.isArray(urgency)) {
                _queryParams["urgency"] = urgency.map((item) => item);
            } else {
                _queryParams["urgency"] = urgency;
            }
        }

        if (zone != null) {
            if (Array.isArray(zone)) {
                _queryParams["zone"] = zone.map((item) => item);
            } else {
                _queryParams["zone"] = zone;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "alerts/active"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns active alerts for the given area (state or marine area)
     *
     * @param {WeatherGov.AreaCode} area - State/area ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveArea("AL")
     */
    public async alertsActiveArea(
        area: WeatherGov.AreaCode,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `alerts/active/area/${encodeURIComponent(area)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /alerts/active/area/{area}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns info on the number of active alerts
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveCount()
     */
    public async alertsActiveCount(
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertsActiveCountResponse> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "alerts/active/count"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertsActiveCountResponse;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/active/count.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns active alerts for the given marine region
     *
     * @param {WeatherGov.MarineRegionCode} region - Marine region ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveRegion("AL")
     */
    public async alertsActiveRegion(
        region: WeatherGov.MarineRegionCode,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `alerts/active/region/${encodeURIComponent(region)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /alerts/active/region/{region}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns active alerts for the given NWS public zone or county
     *
     * @param {WeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsActiveZone("zoneId")
     */
    public async alertsActiveZone(
        zoneId: WeatherGov.NwsZoneId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `alerts/active/zone/${encodeURIComponent(zoneId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /alerts/active/zone/{zoneId}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns all alerts
     *
     * @param {WeatherGov.AlertsQueryRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsQuery()
     */
    public async alertsQuery(
        request: WeatherGov.AlertsQueryRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertCollectionGeoJson> {
        const {
            active,
            area,
            certainty,
            code,
            cursor,
            end,
            event,
            limit,
            message_type: messageType,
            point,
            region,
            region_type: regionType,
            severity,
            start,
            status,
            urgency,
            zone,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (active != null) {
            _queryParams["active"] = active.toString();
        }

        if (area != null) {
            if (Array.isArray(area)) {
                _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
            }
        }

        if (certainty != null) {
            if (Array.isArray(certainty)) {
                _queryParams["certainty"] = certainty.map((item) => item);
            } else {
                _queryParams["certainty"] = certainty;
            }
        }

        if (code != null) {
            if (Array.isArray(code)) {
                _queryParams["code"] = code.map((item) => item);
            } else {
                _queryParams["code"] = code;
            }
        }

        if (cursor != null) {
            _queryParams["cursor"] = cursor;
        }

        if (end != null) {
            _queryParams["end"] = end;
        }

        if (event != null) {
            if (Array.isArray(event)) {
                _queryParams["event"] = event.map((item) => item);
            } else {
                _queryParams["event"] = event;
            }
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (messageType != null) {
            if (Array.isArray(messageType)) {
                _queryParams["message_type"] = messageType.map((item) => item);
            } else {
                _queryParams["message_type"] = messageType;
            }
        }

        if (point != null) {
            _queryParams["point"] = point;
        }

        if (region != null) {
            if (Array.isArray(region)) {
                _queryParams["region"] = region.map((item) => item);
            } else {
                _queryParams["region"] = region;
            }
        }

        if (regionType != null) {
            _queryParams["region_type"] = regionType;
        }

        if (severity != null) {
            if (Array.isArray(severity)) {
                _queryParams["severity"] = severity.map((item) => item);
            } else {
                _queryParams["severity"] = severity;
            }
        }

        if (start != null) {
            _queryParams["start"] = start;
        }

        if (status != null) {
            if (Array.isArray(status)) {
                _queryParams["status"] = status.map((item) => item);
            } else {
                _queryParams["status"] = status;
            }
        }

        if (urgency != null) {
            if (Array.isArray(urgency)) {
                _queryParams["urgency"] = urgency.map((item) => item);
            } else {
                _queryParams["urgency"] = urgency;
            }
        }

        if (zone != null) {
            if (Array.isArray(zone)) {
                _queryParams["zone"] = zone.map((item) => item);
            } else {
                _queryParams["zone"] = zone;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "alerts"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /alerts.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a specific alert
     *
     * @param {WeatherGov.AlertId} id - Alert identifier
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsSingle("id")
     */
    public async alertsSingle(
        id: WeatherGov.AlertId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), `alerts/${encodeURIComponent(id)}`),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/{id}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of alert types
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alertsTypes()
     */
    public async alertsTypes(
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.AlertsTypesResponse> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "alerts/types"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.AlertsTypesResponse;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /alerts/types.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of Center Weather Advisories from a CWSU
     *
     * @param {WeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {WeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {number} sequence - Sequence number
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwa("ZAB", "date", 1)
     */
    public async cwa(
        cwsuId: WeatherGov.NwsCenterWeatherServiceUnitId,
        date: WeatherGov.Date_,
        sequence: number,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.CenterWeatherAdvisoryGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/cwsus/${encodeURIComponent(cwsuId)}/cwas/${encodeURIComponent(date)}/${encodeURIComponent(sequence)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.CenterWeatherAdvisoryGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of Center Weather Advisories from a CWSU
     *
     * @param {WeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwas("ZAB")
     */
    public async cwas(
        cwsuId: WeatherGov.NwsCenterWeatherServiceUnitId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.CenterWeatherAdvisoryCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/cwsus/${encodeURIComponent(cwsuId)}/cwas`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.CenterWeatherAdvisoryCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}/cwas.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a Center Weather Service Unit
     *
     * @param {WeatherGov.NwsCenterWeatherServiceUnitId} cwsuId - NWS CWSU ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.cwsu("ZAB")
     */
    public async cwsu(
        cwsuId: WeatherGov.NwsCenterWeatherServiceUnitId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.CenterWeatherServiceUnitJsonLd> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/cwsus/${encodeURIComponent(cwsuId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.CenterWeatherServiceUnitJsonLd;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/cwsus/{cwsuId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns glossary terms
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.glossary()
     */
    public async glossary(requestOptions?: WeatherGovClient.RequestOptions): Promise<WeatherGov.GlossaryResponse> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "glossary"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.GlossaryResponse;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /glossary.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     *
     * @param {WeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpoint("AKQ", 1, 1)
     */
    public async gridpoint(
        wfo: WeatherGov.NwsForecastOfficeId,
        x: number,
        y: number,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.GridpointGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.GridpointGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a textual forecast for a 2.5km grid area
     *
     * @param {WeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {WeatherGov.GridpointForecastRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointForecast("AKQ", 1, 1)
     */
    public async gridpointForecast(
        wfo: WeatherGov.NwsForecastOfficeId,
        x: number,
        y: number,
        request: WeatherGov.GridpointForecastRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.GridpointForecastGeoJson> {
        const { units, "Feature-Flags": featureFlags } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (units != null) {
            _queryParams["units"] = units;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/forecast`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Feature-Flags": featureFlags != null ? JSON.stringify(featureFlags) : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.GridpointForecastGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/forecast.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     *
     * @param {WeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {WeatherGov.GridpointForecastHourlyRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointForecastHourly("AKQ", 1, 1)
     */
    public async gridpointForecastHourly(
        wfo: WeatherGov.NwsForecastOfficeId,
        x: number,
        y: number,
        request: WeatherGov.GridpointForecastHourlyRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.GridpointForecastGeoJson> {
        const { units, "Feature-Flags": featureFlags } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (units != null) {
            _queryParams["units"] = units;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/forecast/hourly`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "Feature-Flags": featureFlags != null ? JSON.stringify(featureFlags) : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.GridpointForecastGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/forecast/hourly.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     *
     * @param {WeatherGov.NwsForecastOfficeId} wfo - Forecast office ID
     * @param {number} x - Forecast grid X coordinate
     * @param {number} y - Forecast grid Y coordinate
     * @param {WeatherGov.GridpointStationsRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.gridpointStations("AKQ", 1, 1)
     */
    public async gridpointStations(
        wfo: WeatherGov.NwsForecastOfficeId,
        x: number,
        y: number,
        request: WeatherGov.GridpointStationsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationStationCollectionGeoJson> {
        const { cursor, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (cursor != null) {
            _queryParams["cursor"] = cursor;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `gridpoints/${encodeURIComponent(wfo)}/${encodeURIComponent(x)},${encodeURIComponent(y)}/stations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationStationCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /gridpoints/{wfo}/{x}/,/{y}/stations.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     */
    public async icons(
        first: string,
        set_: string,
        timeOfDay: string,
        request: WeatherGov.IconsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<stream.Readable> {
        const { fontsize, size } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (fontsize != null) {
            _queryParams["fontsize"] = fontsize.toString();
        }

        if (size != null) {
            _queryParams["size"] = size;
        }

        const _response = await core.fetcher<stream.Readable>({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `icons/${encodeURIComponent(set_)}/${encodeURIComponent(timeOfDay)}/${encodeURIComponent(first)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            responseType: "streaming",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /icons/{set}/{timeOfDay}/{first}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.iconsSummary()
     */
    public async iconsSummary(
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.IconsSummaryResponse> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "icons"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.IconsSummaryResponse;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /icons.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     */
    public async iconsDualCondition(
        first: string,
        second: string,
        set_: string,
        timeOfDay: string,
        request: WeatherGov.IconsDualConditionRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<stream.Readable> {
        const { fontsize, size } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (fontsize != null) {
            _queryParams["fontsize"] = fontsize.toString();
        }

        if (size != null) {
            _queryParams["size"] = size;
        }

        const _response = await core.fetcher<stream.Readable>({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `icons/${encodeURIComponent(set_)}/${encodeURIComponent(timeOfDay)}/${encodeURIComponent(first)}/${encodeURIComponent(second)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            responseType: "streaming",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /icons/{set}/{timeOfDay}/{first}/{second}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of valid text product types for a given issuance location
     *
     * @param {string} locationId - .
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.locationProducts("locationId")
     */
    public async locationProducts(
        locationId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductTypeCollection> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `products/locations/${encodeURIComponent(locationId)}/types`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductTypeCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /products/locations/{locationId}/types.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given observation station
     *
     * @param {string} stationId - Observation station ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.obsStation("stationId")
     */
    public async obsStation(
        stationId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationStationGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationStationGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /stations/{stationId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observation stations.
     *
     * @param {WeatherGov.ObsStationsRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.obsStations()
     */
    public async obsStations(
        request: WeatherGov.ObsStationsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationStationCollectionGeoJson> {
        const { cursor, id, limit, state } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (cursor != null) {
            _queryParams["cursor"] = cursor;
        }

        if (id != null) {
            if (Array.isArray(id)) {
                _queryParams["id"] = id.map((item) => item);
            } else {
                _queryParams["id"] = id;
            }
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (state != null) {
            if (Array.isArray(state)) {
                _queryParams["state"] = state.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["state"] = typeof state === "string" ? state : JSON.stringify(state);
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "stations"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationStationCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /stations.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a NWS forecast office
     *
     * @param {WeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.office("AKQ")
     */
    public async office(
        officeId: WeatherGov.NwsOfficeId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.Office> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), `offices/${encodeURIComponent(officeId)}`),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.Office;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /offices/{officeId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a specific news headline for a given NWS office
     *
     * @param {string} headlineId - Headline record ID
     * @param {WeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.officeHeadline("headlineId", "AKQ")
     */
    public async officeHeadline(
        headlineId: string,
        officeId: WeatherGov.NwsOfficeId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.OfficeHeadline> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `offices/${encodeURIComponent(officeId)}/headlines/${encodeURIComponent(headlineId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.OfficeHeadline;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /offices/{officeId}/headlines/{headlineId}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of news headlines for a given NWS office
     *
     * @param {WeatherGov.NwsOfficeId} officeId - NWS office ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.officeHeadlines("AKQ")
     */
    public async officeHeadlines(
        officeId: WeatherGov.NwsOfficeId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.OfficeHeadlineCollection> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `offices/${encodeURIComponent(officeId)}/headlines`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.OfficeHeadlineCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /offices/{officeId}/headlines.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given latitude/longitude point
     *
     * @param {WeatherGov.PointString} point - Point (latitude, longitude)
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.point("point")
     */
    public async point(
        point: WeatherGov.PointString,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.PointGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), `points/${encodeURIComponent(point)}`),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.PointGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /points/{point}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observation stations for a given point
     *
     * @param {WeatherGov.PointString} point - Point (latitude, longitude)
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.pointStations("point")
     */
    public async pointStations(
        point: WeatherGov.PointString,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ProblemDetail> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `points/${encodeURIComponent(point)}/stations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ProblemDetail;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /points/{point}/stations.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a specific text product
     *
     * @param {string} productId - .
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.product("productId")
     */
    public async product(
        productId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProduct> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `products/${encodeURIComponent(productId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProduct;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /products/{productId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of valid text product issuance locations
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productLocations()
     */
    public async productLocations(
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductLocationCollection> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "products/locations"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductLocationCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /products/locations.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of valid text product types and codes
     *
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productTypes()
     */
    public async productTypes(
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductTypeCollection> {
        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "products/types"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductTypeCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /products/types.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of text products
     *
     * @param {WeatherGov.ProductsQueryRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsQuery()
     */
    public async productsQuery(
        request: WeatherGov.ProductsQueryRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductCollection> {
        const { end, limit, location, office, start, type: type_, wmoid } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (end != null) {
            _queryParams["end"] = end;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (location != null) {
            if (Array.isArray(location)) {
                _queryParams["location"] = location.map((item) => item);
            } else {
                _queryParams["location"] = location;
            }
        }

        if (office != null) {
            if (Array.isArray(office)) {
                _queryParams["office"] = office.map((item) => item);
            } else {
                _queryParams["office"] = office;
            }
        }

        if (start != null) {
            _queryParams["start"] = start;
        }

        if (type_ != null) {
            if (Array.isArray(type_)) {
                _queryParams["type"] = type_.map((item) => item);
            } else {
                _queryParams["type"] = type_;
            }
        }

        if (wmoid != null) {
            if (Array.isArray(wmoid)) {
                _queryParams["wmoid"] = wmoid.map((item) => item);
            } else {
                _queryParams["wmoid"] = wmoid;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "products"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /products.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of text products of a given type
     *
     * @param {string} typeId - .
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsType("typeId")
     */
    public async productsType(
        typeId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductCollection> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `products/types/${encodeURIComponent(typeId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /products/types/{typeId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of text products of a given type for a given issuance location
     *
     * @param {string} locationId - .
     * @param {string} typeId - .
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsTypeLocation("locationId", "typeId")
     */
    public async productsTypeLocation(
        locationId: string,
        typeId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductCollection> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `products/types/${encodeURIComponent(typeId)}/locations/${encodeURIComponent(locationId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /products/types/{typeId}/locations/{locationId}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of valid text product issuance locations for a given product type
     *
     * @param {string} typeId - .
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.productsTypeLocations("typeId")
     */
    public async productsTypeLocations(
        typeId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.TextProductLocationCollection> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `products/types/${encodeURIComponent(typeId)}/locations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.TextProductLocationCollection;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /products/types/{typeId}/locations.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given radar wind profiler
     *
     * @param {string} stationId - Profiler station ID
     * @param {WeatherGov.RadarProfilerRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarProfiler("stationId", {
     *         interval: "P2DT12H",
     *         time: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
     *     })
     */
    public async radarProfiler(
        stationId: string,
        request: WeatherGov.RadarProfilerRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { interval, time } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (interval != null) {
            _queryParams["interval"] = interval;
        }

        if (time != null) {
            _queryParams["time"] = time;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `radar/profilers/${encodeURIComponent(stationId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /radar/profilers/{stationId}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given radar queue
     *
     * @param {string} host - LDM host
     * @param {WeatherGov.RadarQueueRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarQueue("host", {
     *         arrived: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z",
     *         created: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z",
     *         published: "P1Y2M10DT2H30M/2008-05-11T15:30:00Z"
     *     })
     */
    public async radarQueue(
        host: string,
        request: WeatherGov.RadarQueueRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { arrived, created, feed, limit, published, resolution, station, type: type_ } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (arrived != null) {
            _queryParams["arrived"] = arrived;
        }

        if (created != null) {
            _queryParams["created"] = created;
        }

        if (feed != null) {
            _queryParams["feed"] = feed;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (published != null) {
            _queryParams["published"] = published;
        }

        if (resolution != null) {
            _queryParams["resolution"] = resolution.toString();
        }

        if (station != null) {
            _queryParams["station"] = station;
        }

        if (type_ != null) {
            _queryParams["type"] = type_;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `radar/queues/${encodeURIComponent(host)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /radar/queues/{host}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given radar server
     *
     * @param {string} id - Server ID
     * @param {WeatherGov.RadarServerRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarServer("id")
     */
    public async radarServer(
        id: string,
        request: WeatherGov.RadarServerRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { reportingHost } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (reportingHost != null) {
            _queryParams["reportingHost"] = reportingHost;
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), `radar/servers/${encodeURIComponent(id)}`),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /radar/servers/{id}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of radar servers
     *
     * @param {WeatherGov.RadarServersRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarServers()
     */
    public async radarServers(
        request: WeatherGov.RadarServersRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { reportingHost } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (reportingHost != null) {
            _queryParams["reportingHost"] = reportingHost;
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "radar/servers"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /radar/servers.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given radar station
     *
     * @param {string} stationId - Radar station ID
     * @param {WeatherGov.RadarStationRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStation("stationId")
     */
    public async radarStation(
        stationId: string,
        request: WeatherGov.RadarStationRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { host, reportingHost } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (host != null) {
            _queryParams["host"] = host;
        }

        if (reportingHost != null) {
            _queryParams["reportingHost"] = reportingHost;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `radar/stations/${encodeURIComponent(stationId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /radar/stations/{stationId}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given radar station alarms
     *
     * @param {string} stationId - Radar station ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStationAlarms("stationId")
     */
    public async radarStationAlarms(
        stationId: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `radar/stations/${encodeURIComponent(stationId)}/alarms`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /radar/stations/{stationId}/alarms.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of radar stations
     *
     * @param {WeatherGov.RadarStationsRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.radarStations()
     */
    public async radarStations(
        request: WeatherGov.RadarStationsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<unknown> {
        const { host, reportingHost, stationType } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (host != null) {
            _queryParams["host"] = host;
        }

        if (reportingHost != null) {
            _queryParams["reportingHost"] = reportingHost;
        }

        if (stationType != null) {
            if (Array.isArray(stationType)) {
                _queryParams["stationType"] = stationType.map((item) => item);
            } else {
                _queryParams["stationType"] = stationType;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "radar/stations"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /radar/stations.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     */
    public async satelliteThumbnails(
        area: WeatherGov.SatelliteThumbnailsRequestArea,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<stream.Readable> {
        const _response = await core.fetcher<stream.Readable>({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `thumbnails/satellite/${encodeURIComponent(area)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            responseType: "streaming",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /thumbnails/satellite/{area}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a specific SIGMET/AIRMET
     *
     * @param {WeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {WeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {WeatherGov.Time} time - Time (HHMM format). This time is always specified in UTC (Zulu) time.
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmet("atsu", "date", "time")
     */
    public async sigmet(
        atsu: WeatherGov.AtsuIdentifier,
        date: WeatherGov.Date_,
        time: WeatherGov.Time,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.SigmetGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/sigmets/${encodeURIComponent(atsu)}/${encodeURIComponent(date)}/${encodeURIComponent(time)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.SigmetGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /aviation/sigmets/{atsu}/{date}/{time}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of SIGMET/AIRMETs
     *
     * @param {WeatherGov.SigmetQueryRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetQuery()
     */
    public async sigmetQuery(
        request: WeatherGov.SigmetQueryRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.SigmetCollectionGeoJson> {
        const { atsu, date, end, sequence, start } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (atsu != null) {
            _queryParams["atsu"] = atsu;
        }

        if (date != null) {
            _queryParams["date"] = date;
        }

        if (end != null) {
            _queryParams["end"] = end;
        }

        if (sequence != null) {
            _queryParams["sequence"] = sequence;
        }

        if (start != null) {
            _queryParams["start"] = start;
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "aviation/sigmets"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.SigmetCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU
     *
     * @param {WeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetsByAtsu("atsu")
     */
    public async sigmetsByAtsu(
        atsu: WeatherGov.AtsuIdentifier,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.SigmetCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/sigmets/${encodeURIComponent(atsu)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.SigmetCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /aviation/sigmets/{atsu}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
     *
     * @param {WeatherGov.AtsuIdentifier} atsu - ATSU identifier
     * @param {WeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.sigmetsByAtsuByDate("atsu", "date")
     */
    public async sigmetsByAtsuByDate(
        atsu: WeatherGov.AtsuIdentifier,
        date: WeatherGov.Date_,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.SigmetCollectionGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `aviation/sigmets/${encodeURIComponent(atsu)}/${encodeURIComponent(date)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.SigmetCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /aviation/sigmets/{atsu}/{date}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns the latest observation for a station
     *
     * @param {string} stationId - Observation station ID
     * @param {WeatherGov.StationObservationLatestRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationLatest("stationId")
     */
    public async stationObservationLatest(
        stationId: string,
        request: WeatherGov.StationObservationLatestRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationGeoJson> {
        const { require_qc: requireQc } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (requireQc != null) {
            _queryParams["require_qc"] = requireQc.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}/observations/latest`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /stations/{stationId}/observations/latest.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observations for a given station
     *
     * @param {string} stationId - Observation station ID
     * @param {WeatherGov.StationObservationListRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationList("stationId")
     */
    public async stationObservationList(
        stationId: string,
        request: WeatherGov.StationObservationListRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationCollectionGeoJson> {
        const { end, limit, start } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (end != null) {
            _queryParams["end"] = end;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (start != null) {
            _queryParams["start"] = start;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}/observations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /stations/{stationId}/observations.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a single observation.
     *
     * @param {string} stationId - Observation station ID
     * @param {string} time - Timestamp of requested observation
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stationObservationTime("stationId", "2024-01-15T09:30:00Z")
     */
    public async stationObservationTime(
        stationId: string,
        time: string,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}/observations/${encodeURIComponent(time)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /stations/{stationId}/observations/{time}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a single Terminal Aerodrome Forecast.
     *
     * @param {WeatherGov.Date_} date - Date (YYYY-MM-DD format)
     * @param {string} stationId - Observation station ID
     * @param {WeatherGov.Time} time - Time (HHMM format). This time is always specified in UTC (Zulu) time.
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.taf("date", "stationId", "time")
     */
    public async taf(
        date: WeatherGov.Date_,
        stationId: string,
        time: WeatherGov.Time,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}/tafs/${encodeURIComponent(date)}/${encodeURIComponent(time)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /stations/{stationId}/tafs/{date}/{time}.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns Terminal Aerodrome Forecasts for the specified airport station.
     *
     * @param {string} stationId - Observation station ID
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.tafs("stationId")
     */
    public async tafs(stationId: string, requestOptions?: WeatherGovClient.RequestOptions): Promise<unknown> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `stations/${encodeURIComponent(stationId)}/tafs`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /stations/{stationId}/tafs.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns metadata about a given zone
     *
     * @param {WeatherGov.NwsZoneType} type_ - Zone type
     * @param {WeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {WeatherGov.ZoneRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zone("land", "zoneId")
     */
    public async zone(
        type_: WeatherGov.NwsZoneType,
        zoneId: WeatherGov.NwsZoneId,
        request: WeatherGov.ZoneRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ZoneGeoJson> {
        const { effective } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (effective != null) {
            _queryParams["effective"] = effective;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `zones/${encodeURIComponent(type_)}/${encodeURIComponent(zoneId)}`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ZoneGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /zones/{type}/{zoneId}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns the current zone forecast for a given zone
     *
     * @param {string} type_ - Zone type
     * @param {WeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneForecast("type", "zoneId")
     */
    public async zoneForecast(
        type_: string,
        zoneId: WeatherGov.NwsZoneId,
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ZoneForecastGeoJson> {
        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `zones/${encodeURIComponent(type_)}/${encodeURIComponent(zoneId)}/forecast`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ZoneForecastGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /zones/{type}/{zoneId}/forecast.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of zones
     *
     * @param {WeatherGov.ZoneListRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneList()
     */
    public async zoneList(
        request: WeatherGov.ZoneListRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ZoneCollectionGeoJson> {
        const { area, effective, id, include_geometry: includeGeometry, limit, point, region, type: type_ } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (area != null) {
            if (Array.isArray(area)) {
                _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
            }
        }

        if (effective != null) {
            _queryParams["effective"] = effective;
        }

        if (id != null) {
            if (Array.isArray(id)) {
                _queryParams["id"] = id.map((item) => item);
            } else {
                _queryParams["id"] = id;
            }
        }

        if (includeGeometry != null) {
            _queryParams["include_geometry"] = includeGeometry.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (point != null) {
            _queryParams["point"] = point;
        }

        if (region != null) {
            if (Array.isArray(region)) {
                _queryParams["region"] = region.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["region"] = typeof region === "string" ? region : JSON.stringify(region);
            }
        }

        if (type_ != null) {
            if (Array.isArray(type_)) {
                _queryParams["type"] = type_.map((item) => item);
            } else {
                _queryParams["type"] = type_;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), "zones"),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ZoneCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /zones.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of zones of a given type
     *
     * @param {WeatherGov.NwsZoneType} type_ - Zone type
     * @param {WeatherGov.ZoneListTypeRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneListType("land")
     */
    public async zoneListType(
        type_: WeatherGov.NwsZoneType,
        request: WeatherGov.ZoneListTypeRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ZoneCollectionGeoJson> {
        const { area, effective, id, include_geometry: includeGeometry, limit, point, region, type: type__ } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (area != null) {
            if (Array.isArray(area)) {
                _queryParams["area"] = area.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["area"] = typeof area === "string" ? area : JSON.stringify(area);
            }
        }

        if (effective != null) {
            _queryParams["effective"] = effective;
        }

        if (id != null) {
            if (Array.isArray(id)) {
                _queryParams["id"] = id.map((item) => item);
            } else {
                _queryParams["id"] = id;
            }
        }

        if (includeGeometry != null) {
            _queryParams["include_geometry"] = includeGeometry.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (point != null) {
            _queryParams["point"] = point;
        }

        if (region != null) {
            if (Array.isArray(region)) {
                _queryParams["region"] = region.map((item) => (typeof item === "string" ? item : JSON.stringify(item)));
            } else {
                _queryParams["region"] = typeof region === "string" ? region : JSON.stringify(region);
            }
        }

        if (type__ != null) {
            if (Array.isArray(type__)) {
                _queryParams["type"] = type__.map((item) => item);
            } else {
                _queryParams["type"] = type__;
            }
        }

        const _response = await core.fetcher({
            url: urlJoin(await core.Supplier.get(this._options.environment), `zones/${encodeURIComponent(type_)}`),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ZoneCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError("Timeout exceeded when calling GET /zones/{type}.");
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observations for a given zone
     *
     * @param {WeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {WeatherGov.ZoneObsRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneObs("zoneId")
     */
    public async zoneObs(
        zoneId: WeatherGov.NwsZoneId,
        request: WeatherGov.ZoneObsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationCollectionGeoJson> {
        const { end, limit, start } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (end != null) {
            _queryParams["end"] = end;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (start != null) {
            _queryParams["start"] = start;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `zones/forecast/${encodeURIComponent(zoneId)}/observations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /zones/forecast/{zoneId}/observations.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of observation stations for a given zone
     *
     * @param {WeatherGov.NwsZoneId} zoneId - NWS public zone/county identifier
     * @param {WeatherGov.ZoneStationsRequest} request
     * @param {WeatherGovClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.zoneStations("zoneId")
     */
    public async zoneStations(
        zoneId: WeatherGov.NwsZoneId,
        request: WeatherGov.ZoneStationsRequest = {},
        requestOptions?: WeatherGovClient.RequestOptions,
    ): Promise<WeatherGov.ObservationStationCollectionGeoJson> {
        const { cursor, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        if (cursor != null) {
            _queryParams["cursor"] = cursor;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        const _response = await core.fetcher({
            url: urlJoin(
                await core.Supplier.get(this._options.environment),
                `zones/forecast/${encodeURIComponent(zoneId)}/stations`,
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return _response.body as WeatherGov.ObservationStationCollectionGeoJson;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.WeatherGovError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.WeatherGovError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.WeatherGovTimeoutError(
                    "Timeout exceeded when calling GET /zones/forecast/{zoneId}/stations.",
                );
            case "unknown":
                throw new errors.WeatherGovError({
                    message: _response.error.errorMessage,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const userAgentValue = await core.Supplier.get(this._options.userAgent);
        return { "User-Agent": userAgentValue };
    }
}
